<?xml version="1.0"?><st-source><!-- Name: StoreCI-BuildingNotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: # StoreCIIntegrate Cincom Visualworks Smalltalk with a Continuous Integration server.StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.StoreCI's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/StoreCI).StoreCI was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  It uses the newer Glorp-based Store implementation, so will not work in 7.6 or earlier.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# StoreCI-BuildingStoreCI-Building loads a set of pundles from a Store repository into an image, and optionally deploys them as parcels.  It is intended to be used as part of an automated build, perhaps driven from a Continuous Integration system such as Jenkins or CruiseControl.When deploying parcels, StoreCI-Building also copies in any "stock" parcels that are used by the loaded pundles.  Stock parcels are those that are shipped with Visualworks.  This is done so that there is a complete, standalone set of parcels available that will load cleanly into a base runtime image.## UsageStoreCI-Building is intended to be run from a command-line or automated build script.  It requires an image that has StoreCI-Building already loaded, or with a base image and command-line options to load StoreCI-Building from a parcel.  The image also needs to contain any necessary Store database interface pundles and Store repository definitions for the repositories that you want to monitor.  As an alternative, you can use the `-repositoriesFrom` argument (see `ImportRepositoriesSubsystem` in StoreCI-Support).Run the image as follows:	/path/to/VM /path/to/image <command-line options>or:	/path/to/VM /path/to/image -pcl /path/to/StoreCI-Building <command-line options>The allowable command line options are:* (Optional) `-repositoriesFrom <Filename>`: The name of a file containing the necessary Store repository definitions.  See `ImportRepositoriesSubsystem` in `StoreCI-Support` for more information.* (Required) `-repository <Name>`: The name of the Store repository to build from.  The image containing StoreCI-Building must have a repository defined with this name.* (Required) `-loadPundlesIn <Filename>`: The name of a file containing the list of pundles to load.  See below.* (Optional) `-writeParcelsTo <Directory>`: The name of the directory where parcels will be created.  If it does not exist, it will be created.* (Optional) `-debug`: When specified, exceptions will not be trapped and the image will not exit upon completion.The input file must be in the same format as that produced by the `-parcelBuilderFile` option of StoreCI-Polling.  That is, each pundle to be loaded should be on its own line in the file.  Each line has the format:	PundleClassName<tab>"Name in Double Quotes"<tab>PundleVersionwhere `PundleClassName` is either `StorePackage` or `StoreBundle`.## Understanding the Code`BuildingSubsystem` is the main entry point for the command-line application.  It processes command-line arguments, configures a `PundleLoader` and optionally a `ParcelWriter`, and then invokes the desired operations  See the class and method comments for more information.# ContributingI'm happy to receive bug fixes and improvements to this package.  If you'd like to contribute, please publish your changes as a "branch" (non-integer) version in the Public Store Repository and contact me as outlined below to let me know.  I will merge your changes back into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about this package and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1703DbUsername: randyDbVersion: 49DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'StoreCI-Support' '') #(#any 'StoreCI-StoreSupport' '') #(#any 'ParcelDeployment' '') #(#any 'StoreBase' ''))PackageName: StoreCI-BuildingParcel: #('StoreCI-Building')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'StoreCI-Support' #componentType #package) #(#name 'StoreCI-StoreSupport' #componentType #package) #(#name 'ParcelDeployment') #(#name 'StoreBase' #componentType #bundle))PrerequisiteParcels: #(#('Base VisualWorks' '') #('StoreCI-Support' '') #('StoreCI-StoreSupport' '') #('ParcelDeployment' '') #('StoreBase' ''))PrintStringCache: (49,randy)Version: 49Date: 2:44:13 PM October 3, 2014 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.10.1 of February 6, 2014 on October 3, 2014 at 2:44:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Building</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private StoreCI.Support.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreCI-Building</package></attributes></name-space><class><name>ParcelWriteFailure</name><environment>StoreCI.Building</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.ParcelWriteFailure</class-id><body>ParcelWriteFailure is raised if a stock parcel cannot be copied into the target directory for some reason.</body></comment><class><name>BuildingSubsystem</name><environment>StoreCI.Building</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetDirectory repository inputFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ParcelBuilder</category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.BuildingSubsystem</class-id><body>BuildingSubsystem is the main command-line entry point for StoreCI-Building.  See the package comment for details on usage and command-line options.BuildingSubsystem is designed to be inert unless it is given a repository name and an input file name.  When those arguments are provided, it configures an instance of PundleLoader to load the desired pundles and, if required, an instance of ParcelWriter to write them out as parcels.Instance Variables	inputFilename	&lt;Filename&gt;	The name of the file containing the list of pundles to load.	repository	&lt;Store.ConnectionProfile&gt;	The repository from which to load pundles.	targetDirectory	&lt;Filename&gt;	The directory to which parcels will be written.</body></comment><class><name>ParcelWriter</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.ParcelWriter</class-id><body>ParcelWriter parcels out a list of pundles along with any "stock" parcels that are depended on by the pundles.Instance Variables	directory	&lt;Filename&gt;	The directory where the parcels will be written.  Will be created if it does not already exist.</body></comment><class><name>PundleLoader</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleSpecs session imagePundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.PundleLoader</class-id><body>Given a Store repository and an input file, ParcelLoader loads all of the pundles listed in the file from the repository, keeping track of the loaded pundles..Instance Variables	imagePundles	&lt;Collection&gt;	The in-image loaded pundles.	pundleSpecs	&lt;(Collection of: PundleSpec)&gt;	The specifications of which versions of which pundles to load.	session	&lt;GlorpSession&gt;	The active Glorp session.</body></comment><class><name>StockParcels</name><environment>StoreCI.Building</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>storePundles stockParcels </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Building</package></attributes></class><comment><class-id>StoreCI.Building.StockParcels</class-id><body>StockParcels computes a list of "stock" parcels that are depended upon by a set of pundles.  Stock parcels are those that aren't in the given Store repository, but ship with Visualworks instead.Working in reverse load-order, so that a pundle is processed before any of its prerequisites, we add each pundle and all of its deployment prerequisites to the list of stock parcels.  We then remove the pundle (and any of its components if it is a bundle) from the list.  Once this is done, the only pundles remaining in the list are stock parcels.Instance Variables	stockParcels	&lt;Collection&gt;	The stock parcels that were computed.	storePundles	&lt;Collection&gt;	The list of pundles being parceled out.</body></comment><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Building">clearCachedState	"Subsystem instances live forever in an image, so we need a way to reset the state when loading the image"	super clearCachedState.	repository := nil.	inputFilename := nil</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>testing</category><body package="StoreCI-Building">isReadyToRun	^repository notNil and: [inputFilename notNil]</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>private</category><body package="StoreCI-Building">configuredLoader	^PundleLoader repository: repository inputFile: inputFilename</body><body package="StoreCI-Building">configuredWriter	^ParcelWriter directory: targetDirectory</body><body package="StoreCI-Building">repositoryNamed: aString	^Store.RepositoryManager repositories		detect: [:each | each name = aString]		ifNone: [RepositoryNotFound raiseWith: aString]</body><body package="StoreCI-Building">run	| loader |	loader := self configuredLoader.	self withOverlayFeedbackDo: 			[loader loadPundles.			targetDirectory				ifNotNil: [self configuredWriter writeParcels: loader imagePundles]]</body><body package="StoreCI-Building">withOverlayFeedbackDo: aBlock	"If StoreProgressOverlay is available in the image, use it on the active VisualLauncher window."	#{Store.StoreProgressOverlay} ifDefinedDo: 			[:cls |			| activeLauncher |			activeLauncher := VisualLauncher allInstances						detect: [:each | each mainWindow isOpen].			cls subsume: activeLauncher mainWindow while: aBlock]		elseDo: aBlock</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>prerequisites</category><body package="StoreCI-Building">prerequisiteSystems	^super prerequisiteSystems copyWith: ImportRepositoriesSubsystem</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>private</category><body package="StoreCI-Building">copy: aFilename to: aDirectory	| target |	target := aDirectory / aFilename tail.	aFilename copyTo: target.	target makeWritable</body><body package="StoreCI-Building">copyStockParcel: aPundleModel	| parcelFilename |	parcelFilename := (self parcelFilenameFor: aPundleModel)				ifNil: 					[^ParcelWriteFailure						raiseErrorString: 'Could not deploy ' , aPundleModel printString].	self copyStockParcelFrom: parcelFilename asAbsoluteFilename</body><body package="StoreCI-Building">copyStockParcelFrom: aFilename	| sourceFilename |	aFilename directory = directory asAbsoluteFilename ifTrue: [^self].	sourceFilename := aFilename constructWithExtension: Parcel sourceExtension.	self		copy: aFilename to: directory;		copy: sourceFilename to: directory</body><body package="StoreCI-Building">copyStockParcels: aCollection	aCollection do: [:each | self copyStockParcel: each]</body><body package="StoreCI-Building">parcelFilenameFor: aPundleModel	^aPundleModel parcelFilename		ifNil: [(Parcel parcelNamed: aPundleModel name) ifNotNil: #parcelFilename]</body><body package="StoreCI-Building">writeStoreParcel: aPundleModel	(ParcelDeployment pundle: aPundleModel directory: directory) deploy</body><body package="StoreCI-Building">writeStoreParcels: aCollection	aCollection do: [:each | self writeStoreParcel: each]</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeDirectory: aFilename	directory := aFilename</body></methods><methods><class-id>StoreCI.Building.ParcelWriter</class-id> <category>writing</category><body package="StoreCI-Building">writeParcels: aCollection	"Parcel out all of the pundles in aCollection.  Also, copy over any 'stock' parcels depended on by the pundes."	self		writeStoreParcels: aCollection;		copyStockParcels: (StockParcels from: aCollection)</body></methods><methods><class-id>StoreCI.Building.ParcelWriter class</class-id> <category>instance creation</category><body package="StoreCI-Building">directory: aFilename	^self new initializeDirectory: aFilename</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>private</category><body package="StoreCI-Building">readPundleSpecs: aFilename	| rs |	rs := aFilename readStream.	^[PundleSpec allFrom: rs] ensure: [rs close]</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeRepository: aConnectionProfile inputFile: aFilename	session := StoreLoginFactory sessionForStoreLogin: aConnectionProfile.	pundleSpecs := self readPundleSpecs: aFilename</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>loading</category><body package="StoreCI-Building">loadPundles	"Load each specified pundle, keeping track of the loaded (in-image) version."	imagePundles := pundleSpecs collect: [:each | each loadIn: session]</body></methods><methods><class-id>StoreCI.Building.PundleLoader</class-id> <category>accessing</category><body package="StoreCI-Building">imagePundles	"Answer the loaded (in-image) version of the pundles that were loaded."	^imagePundles</body></methods><methods><class-id>StoreCI.Building.PundleLoader class</class-id> <category>instance creation</category><body package="StoreCI-Building">repository: aConnectionProfile inputFile: aFilename	^self new initializeRepository: aConnectionProfile inputFile: aFilename</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>private</category><body package="StoreCI-Building">compute	"Compute the set of stock parcels, resolving them to their functional components (so we get containing bundles where appropriate).	Base VisualWorks does not come in its own parcel, and we can safely assume that it is already loaded into any image we might use,	so we omit it here."	storePundles reverseDo: [:each | self computeFrom: each].	stockParcels := stockParcels collect: #functionalComponent.	stockParcels remove: (Store.Registry bundleNamed: 'Base VisualWorks')		ifAbsent: []</body><body package="StoreCI-Building">computeFrom: aPundleModel	(stockParcels includes: aPundleModel)		ifFalse: [stockParcels addAll: aPundleModel withAllDeploymentPrerequisites].	aPundleModel withAllContainedItems		do: [:each | stockParcels remove: each ifAbsent: []]</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>accessing</category><body package="StoreCI-Building">stockParcels	^stockParcels</body></methods><methods><class-id>StoreCI.Building.StockParcels</class-id> <category>initialize-release</category><body package="StoreCI-Building">initializeStorePundles: aCollection	storePundles := aCollection.	stockParcels := Set new.	self compute</body></methods><methods><class-id>StoreCI.Building.StockParcels class</class-id> <category>instance creation</category><body package="StoreCI-Building">from: aCollection	| inst |	inst := self new initializeStorePundles: aCollection.	^inst stockParcels</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>loading</category><body package="StoreCI-Building">loadIn: aGlorpSession	"Load the pundle I specify, using an existing Glorp session."	^(self storePundleIn: aGlorpSession) loadSource</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>private</category><body package="StoreCI-Building">storePundleIn: aGlorpSession	^pundleType pundleWithName: name version: version in: aGlorpSession</body></methods><methods><class-id>StoreCI.Building.BuildingSubsystem</class-id> <category>command line</category><body package="StoreCI-Building">inputFile: aStream	&lt;option: '-loadPundlesIn'&gt;	inputFilename := aStream next asFilename</body><body package="StoreCI-Building">repository: aStream	&lt;option: '-repository'&gt;	repository := self repositoryNamed: aStream next</body><body package="StoreCI-Building">targetDirectory: aStream	&lt;option: '-writeParcelsTo'&gt;	targetDirectory := aStream next asFilename</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>StoreCISubsystem</name><environment>StoreCI.Support</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debug errorStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support</package></attributes></class><class><name>PundleSpec</name><environment>StoreCI.Support</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleType name version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-StoreSupport</package></attributes></class></st-source>