<?xml version="1.0"?><st-source><!-- Name: StoreCI-Polling-TestsNotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, or the 'notice' property of this package.This package contains the unit tests for the StoreCI-Polling package.  See that package's comment for more information.DbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1432DbUsername: randyDbVersion: 11DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Regex11' '') #(#any 'StoreBase' '') #(#any 'StoreCI-Support' '') #(#any 'StoreCI-Polling' '') #(#any 'StoreCI-Support-Tests' '') #(#any 'SUnitToo' ''))PackageName: StoreCI-Polling-TestsParcel: #('StoreCI-Polling-Tests')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Regex11' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'StoreCI-Support' #componentType #package) #(#name 'StoreCI-Polling' #componentType #package) #(#name 'StoreCI-Support-Tests' #componentType #package) #(#name 'SUnitToo' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Regex11' '') #('StoreBase' '') #('StoreCI-Support' '') #('StoreCI-Polling' '') #('StoreCI-Support-Tests' '') #('SUnitToo' ''))PrintStringCache: (11,randy)Version: 11Date: 10:01:05 PM March 31, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on March 31, 2013 at 10:01:05 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StubPollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.PollingSubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runBlock exitCode commandLineTokens wroteRevisionState wroteChangelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>RepositoryNotFoundTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>LoadOrderTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubPackageTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubPundle</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name prerequisites timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>PollingSubsystemTest</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>KnownPundleCacheTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cacheFile cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubPackage</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.StubPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubBundle</name><environment>StoreCI.Polling</environment><super>StoreCI.Polling.StubPundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>StubBundleTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>ChangelogTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>BlessingNotFoundTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><class><name>RevisionStateTest</name><environment>StoreCI.Polling</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling-Tests</package></attributes></class><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">wroteChangelog	^wroteChangelog</body><body package="StoreCI-Polling-Tests">wroteRevisionState	^wroteRevisionState</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>private</category><body package="StoreCI-Polling-Tests">configuredSCM	^self</body><body package="StoreCI-Polling-Tests">exitWithCode: anInteger	exitCode := anInteger</body><body package="StoreCI-Polling-Tests">run	runBlock ifNil: [super run] ifNotNil: #value</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Polling-Tests">initialize	super initialize.	commandLineTokens := OrderedCollection with: '/path/to/virtualMachine'				with: ObjectMemory imageName.	wroteRevisionState := false.	wroteChangelog := false</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>self shunt</category><body package="StoreCI-Polling-Tests">writeChangesFrom: aFromTimestamp to: aToTimestamp toFile: aFilename revisionStateTo: aStream	wroteChangelog := true</body><body package="StoreCI-Polling-Tests">writeRevisionStateTo: aStream	wroteRevisionState := true</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">exitCode	^exitCode</body><body package="StoreCI-Polling-Tests">runUsing: aBlock	runBlock := aBlock.	self runActivationActions</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>adding</category><body package="StoreCI-Polling-Tests">addTokens: anArray	commandLineTokens addAll: anArray</body></methods><methods><class-id>StoreCI.Polling.StubPollingSubsystem</class-id> <category>private-activate/deactivate</category><body package="StoreCI-Polling-Tests">commandLine	^commandLineTokens</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^self subclassResponsibility</body><body package="StoreCI-Polling-Tests">name	^name</body><body package="StoreCI-Polling-Tests">prerequisiteDescriptions	^prerequisites</body><body package="StoreCI-Polling-Tests">timestamp	^timestamp</body><body package="StoreCI-Polling-Tests">timestamp: aTimestamp	timestamp := aTimestamp</body><body package="StoreCI-Polling-Tests">version	^'42'</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^self subclassResponsibility</body><body package="StoreCI-Polling-Tests">asXMLElementForStoreCI	^(Element tag: self elementTag)		addAttribute: (Attribute name: 'name' value: name) yourself</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">initializeName: aString prerequisites: aCollection	name := aString.	prerequisites := aCollection collect: 					[:each |					(PrerequisiteDescription new)						name: each name;						componentType: each componentType]</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>printing</category><body package="StoreCI-Polling-Tests">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: (self name ifNil: ['']);		nextPut: $)</body></methods><methods><class-id>StoreCI.Polling.StubPundle</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^self subclassResponsibility</body></methods><methods><class-id>StoreCI.Polling.StubPundle class</class-id> <category>instance creation</category><body package="StoreCI-Polling-Tests">named: aString	^self named: aString prerequisites: #()</body><body package="StoreCI-Polling-Tests">named: aString prerequisites: aCollection	^self new initializeName: aString prerequisites: aCollection</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	super setUp.	self		setUpValidRepository;		setUpValidPackages</body><body package="StoreCI-Polling-Tests">setUpValidPackages	system addTokens: #('-packages' 'MyPackage' 'YourPackage')</body><body package="StoreCI-Polling-Tests">setUpValidRepository	| repositoryName |	repositoryName := Store.RepositoryManager repositories any name.	system addTokens: (Array with: '-repository' with: repositoryName)</body><body package="StoreCI-Polling-Tests">subsystemClass	^StubPollingSubsystem</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">assertBundles: aCollection	self		assertPundles: (aCollection collect: [:each | PundleSpec forBundle: each])</body><body package="StoreCI-Polling-Tests">assertPackages: aCollection	self		assertPundles: (aCollection collect: [:each | PundleSpec forPackage: each])</body><body package="StoreCI-Polling-Tests">assertPundles: aCollection	self assert: (system pundles isSameSequenceAs: aCollection)</body><body package="StoreCI-Polling-Tests">should: aBlock raiseValidationErrorWithMessage: aString		[aBlock value.	self assert: false] on: ValidationError			do: [:ex | self assert: ex errorString = aString]</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	cacheFile := 'test.KnownPundleCache' asFilename.	cache := KnownPundleCache filename: cacheFile</body><body package="StoreCI-Polling-Tests">tearDown	cacheFile exists ifTrue: [cacheFile delete]</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">writeExampleCacheWith: aCollection	cache writeCacheWith: aCollection</body><body package="StoreCI-Polling-Tests">writeLegacyExampleCacheWith: aCollection	| ws |	ws := cacheFile writeStream.	[aCollection do: 			[:each |			ws				nextPutAll: each name;				cr]]		ensure: [ws close]</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^PundleSpec forPackage: name version: self version</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^false</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^StorePackage storeCIElementTag</body></methods><methods><class-id>StoreCI.Polling.StubPackage</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^#()</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">initializeName: aString prerequisites: aCollection	super initializeName: aString prerequisites: aCollection.	children := OrderedCollection new</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>accessing</category><body package="StoreCI-Polling-Tests">containedItems	^children</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>adding</category><body package="StoreCI-Polling-Tests">addChild: aStubPundle	children add: aStubPundle</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>testing</category><body package="StoreCI-Polling-Tests">isBundle	^true</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>private</category><body package="StoreCI-Polling-Tests">elementTag	^StoreBundle storeCIElementTag</body></methods><methods><class-id>StoreCI.Polling.StubBundle</class-id> <category>converting</category><body package="StoreCI-Polling-Tests">asStoreCIPundleSpec	^PundleSpec forBundle: name version: self version</body></methods><methods><class-id>StoreCI.Polling.ChangelogTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">setUp	changelog := Changelog knownPundles: (KnownPundleCache withAll: #())</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">assertBundleRevisionsFor: aPundleSpec in: aDictionary match: anArray	| revisions |	revisions := aDictionary at: (registry at: aPundleSpec).	self assert: (revisions asArray collect: #name) = anArray</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>private</category><body package="StoreCI-Polling-Tests">revisionStateFrom: aCollection	^(RevisionState roots: aCollection)		computeWith: [:each | registry at: each  ifAbsent: [nil]];		yourself</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>initialize-release</category><body package="StoreCI-Polling-Tests">addChild: childPundleSpec toBundle: bundleSpec	(registry at: bundleSpec) addChild: (registry at: childPundleSpec)</body><body package="StoreCI-Polling-Tests">setUp	registry := Dictionary new</body><body package="StoreCI-Polling-Tests">setUpPundle: aPundleSpec	self setUpPundle: aPundleSpec withPrerequisites: #()</body><body package="StoreCI-Polling-Tests">setUpPundle: parentPundleSpec withPrerequisite: childPundleSpec	self setUpPundle: parentPundleSpec		withPrerequisites: (Array with: childPundleSpec)</body><body package="StoreCI-Polling-Tests">setUpPundle: aPundleSpec withPrerequisites: aCollection	| stubClass |	stubClass := aPundleSpec pundleType == StoreBundle				ifTrue: [StubBundle]				ifFalse: [StubPackage].	registry at: aPundleSpec		put: (stubClass named: aPundleSpec name prerequisites: aCollection)</body></methods><methods><class-id>StoreCI.Polling.RepositoryNotFoundTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">hasCorrectErrorMessage	&lt;test&gt;	| expected |	expected := 'Could not find a repository named "No Such Repository"'.	[RepositoryNotFound raiseWith: 'No Such Repository']		on: RepositoryNotFound		do: [:ex | self assert: ex errorString = expected]</body></methods><methods><class-id>StoreCI.Polling.LoadOrderTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">doesntMoveBundlePrereqBackwards	&lt;test&gt;	| package bundle loadOrder dependent prereq other revisions |	prereq := StubPackage named: 'Prereq'.	other := StubPackage named: 'Other'.	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	revisions := (OrderedCollection new)				add: other;				add: prereq;				add: package;				add: dependent;				add: bundle;				yourself.	loadOrder := LoadOrder allRevisions: revisions				bundleRevisions: (Dictionary						with: bundle -&gt; (Array with: prereq with: other with: bundle)).	self		assert: loadOrder revisions asArray = (Array						with: other						with: prereq						with: bundle						with: dependent)</body><body package="StoreCI-Polling-Tests">loadsPackagesInGivenOrder	&lt;test&gt;	| packages loadOrder |	packages := Array with: (StubPackage named: 'A')				with: (StubPackage named: 'B').	loadOrder := LoadOrder allRevisions: packages bundleRevisions: Dictionary new.	self assert: loadOrder revisions asArray  = packages</body><body package="StoreCI-Polling-Tests">movesBundleForwardInLoadOrderWhenNecessary	&lt;test&gt;	| package bundle loadOrder dependent |	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder				allRevisions: (Array with: package with: dependent with: bundle)				bundleRevisions: (Dictionary with: bundle -&gt; (Array with: bundle)).	self		assert: loadOrder revisions asArray = (Array with: bundle with: dependent)</body><body package="StoreCI-Polling-Tests">movesBundlePrereqsForwardWithBundle	&lt;test&gt;	| package bundle loadOrder dependent prereq |	package := StubPackage named: 'Package'.	dependent := StubPackage named: 'Dependent'.	prereq := StubPackage named: 'Prereq'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder allRevisions: (Array						with: package						with: dependent						with: prereq						with: bundle)				bundleRevisions: (Dictionary						with: bundle -&gt; (Array with: prereq with: bundle)).	self assert: loadOrder revisions asArray				= (Array with: prereq with: bundle with: dependent)</body><body package="StoreCI-Polling-Tests">removesPackagesContainedInBundles	&lt;test&gt;	| package bundle loadOrder |	package := StubPackage named: 'Package'.	bundle := StubBundle named: 'Bundle'.	bundle addChild: package.	loadOrder := LoadOrder allRevisions: (Array with: package with: bundle)				bundleRevisions: (Dictionary with: bundle -&gt; (Array with: bundle)).	self assert: loadOrder revisions asArray = (Array with: bundle)</body></methods><methods><class-id>StoreCI.Polling.StubPackageTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">protocolMatchesRealClass	&lt;test&gt;	#(#asStoreCIPundleSpec #asXMLElementForStoreCI #name #prerequisiteDescriptions #timestamp #version #containedItems #isBundle)		do: 			[:each |			self				assert: (StorePackage canUnderstand: each)					description: 'StorePackage doesn''t understand ' , each printString;				assert: (StubPackage canUnderstand: each)					description: 'StubPackage doesn''t understand ' , each printString]</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystemTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">convertsVersionRegexStringToRegex	&lt;test&gt;	system addTokens: #('-versionRegex' '\d+').	system runActivationActions.	self assert: (system versionMatcher isKindOf: RxMatcher)</body><body package="StoreCI-Polling-Tests">doesntRunIfNoPackages	&lt;test&gt;	system := self newSystem.	self setUpValidRepository.	self assertNotRun</body><body package="StoreCI-Polling-Tests">doesntRunIfNoRepository	&lt;test&gt;	system := self newSystem.	self setUpValidPackages.	self assertNotRun</body><body package="StoreCI-Polling-Tests">hasDefaultMinimumBlessingLevel	&lt;test&gt;	self assert: system minimumBlessingLevel				= Store.Policies blessingPolicy developmentBlessing</body><body package="StoreCI-Polling-Tests">looksUpBlessingName	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'Tested').	system runActivationActions.	self		assert: system minimumBlessingLevel = Store.Policies blessingPolicy testedBlessing</body><body package="StoreCI-Polling-Tests">raisesAnErrorWhenBlessingNotFound	&lt;test&gt;	self enableDebugging.	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing').	self should: [system runActivationActions] raise: BlessingNotFound</body><body package="StoreCI-Polling-Tests">raisesAnErrorWhenRepositoryNotFound	&lt;test&gt;	system := self newSystem.	self enableDebugging.	system addTokens: #('-repository' 'No Such Repository').	self should: [system runActivationActions] raise: RepositoryNotFound</body><body package="StoreCI-Polling-Tests">raisesErrorOnImproperlyFormattedTimestamp	&lt;test&gt;	self enableDebugging.	system addTokens: #('-since' '06/31/2012 25:69:81.999').	self should: [system runActivationActions] raise: Error</body><body package="StoreCI-Polling-Tests">requiresChangelogFileForComputingChangelog	&lt;test&gt;	system enableDebugging.	system		addTokens: #('-since' '06/27/2012 09:58:42.654' '-now' '06/27/2012 10:30:03.123').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -changelog option was specified'</body><body package="StoreCI-Polling-Tests">requiresCurrentTimeForComputingChangelog	&lt;test&gt;	system enableDebugging.	system		addTokens: #('-since' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -now option was specified'</body><body package="StoreCI-Polling-Tests">requiresLastBuildTimeForComputingChangelog	&lt;test&gt;	system enableDebugging.	system		addTokens: #('-now' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	self should: [system runActivationActions]		raiseValidationErrorWithMessage: 'No -since option was specified'</body><body package="StoreCI-Polling-Tests">setsDebugFlagBeforeProcessingOtherArguments	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing' '-debug').	self should: [system runActivationActions] raise: BlessingNotFound</body><body package="StoreCI-Polling-Tests">takesListOfBundles	&lt;test&gt;	system := self newSystem.	system addTokens: #('-bundles' 'BundleA' 'BundleB' 'BundleC').	system runActivationActions.	self assertBundles: #('BundleA' 'BundleB' 'BundleC')</body><body package="StoreCI-Polling-Tests">takesListOfPackages	&lt;test&gt;	system := self newSystem.	system addTokens: #('-packages' 'PackageA' 'PackageB' 'PackageC').	system runActivationActions.	self assertPackages: #('PackageA' 'PackageB' 'PackageC')</body><body package="StoreCI-Polling-Tests">takesMixOfPackagesAndBundles	&lt;test&gt;	system := self newSystem.	system addTokens: #('-bundle' 'Bundle' '-package' 'Package').	system runActivationActions.	self assertPundles: (Array with: (PundleSpec forBundle: 'Bundle')				with: (PundleSpec forPackage: 'Package'))</body><body package="StoreCI-Polling-Tests">takesMultipleBundleOptions	&lt;test&gt;	system := self newSystem.	system		addTokens: #('-bundle' 'BundleA' '-bundle' 'BundleB' '-bundle' 'BundleC').	system runActivationActions.	self assertBundles: #('BundleA' 'BundleB' 'BundleC')</body><body package="StoreCI-Polling-Tests">takesMultiplePackageOptions	&lt;test&gt;	system := self newSystem.	system		addTokens: #('-package' 'PackageA' '-package' 'PackageB' '-package' 'PackageC').	system runActivationActions.	self assertPackages: #('PackageA' 'PackageB' 'PackageC')</body><body package="StoreCI-Polling-Tests">trapsArgumentValidationErrors	&lt;test&gt;	system addTokens: #('-blessedAtLeast' 'NoSuchBlessing').	system runActivationActions.	self		assert: errorStream contents notEmpty;		deny: system exitCode isZero</body><body package="StoreCI-Polling-Tests">writesChangelog	&lt;test&gt;	system		addTokens: #('-since' '06/27/2012 09:58:42.654' '-now' '06/27/2012 10:30:03.123' '-changelog' 'changelog.xml').	system runActivationActions.	self assert: system wroteChangelog</body><body package="StoreCI-Polling-Tests">writesRevisionState	&lt;test&gt;	system runActivationActions.	self assert: system wroteRevisionState</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCacheTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">cachesNewPundles	&lt;test&gt;	| expectedContents specs |	specs := Array				with: (PundleSpec forBundle: 'NewA')				with: (PundleSpec forPackage: 'NewB')				with: (PundleSpec forBundle: 'NewC').	cache updateWithPundles: specs.	expectedContents := 'StoreBundle	"NewA"StorePackage	"NewB"StoreBundle	"NewC"'.	self assert: cacheFile contentsOfEntireFile = expectedContents</body><body package="StoreCI-Polling-Tests">canIncludeVersionedPundle	&lt;test&gt;	cache := KnownPundleCache				withAll: (Array with: (PundleSpec forPackage: 'Package')).	self		assert: (cache includes: (PundleSpec forPackage: 'Package' version: '42'))</body><body package="StoreCI-Polling-Tests">computesMissingPundles	&lt;test&gt;	| deleted a b c |	a := PundleSpec forBundle: 'BundleA'.	b := PundleSpec forPackage: 'PackageB'.	c := PundleSpec forPackage: 'PackageC'.	cache := KnownPundleCache withAll: (Array with: a with: b with: c).	deleted := cache pundlesMissingFrom: (Array with: b).	self assert: deleted = (Set with: a with: c)</body><body package="StoreCI-Polling-Tests">isEmptyIfCacheFileDoesntExist	&lt;test&gt;	cache load.	self assert: cache isEmpty</body><body package="StoreCI-Polling-Tests">loadsCache	&lt;test&gt;	| specs |	specs := Array with: (PundleSpec forPackage: 'Package')				with: (PundleSpec forBundle: 'Bundle').	self writeExampleCacheWith: specs.	cache load.	self assert: cache size = specs size.	specs do: [:each | self assert: (cache includes: each)]</body><body package="StoreCI-Polling-Tests">loadsOldFormatCache	&lt;test&gt;	| specs |	specs := #('PackageA' 'PackageB')				collect: [:each | PundleSpec forPackage: each].	self writeLegacyExampleCacheWith: specs.	cache load.	self assert: cache size = specs size.	specs do: [:each | self assert: (cache includes: each)]</body></methods><methods><class-id>StoreCI.Polling.StubBundleTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">protocolMatchesRealClass	&lt;test&gt;	#(#asStoreCIPundleSpec #asXMLElementForStoreCI #name #prerequisiteDescriptions #timestamp #version #containedItems #isBundle)		do: 			[:each |			self				assert: (StoreBundle canUnderstand: each)					description: 'StoreBundle doesn''t understand ' , each printString;				assert: (StubBundle canUnderstand: each)					description: 'StubBundle doesn''t understand ' , each printString]</body></methods><methods><class-id>StoreCI.Polling.ChangelogTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">generatesDeletedPundlesLast	&lt;test&gt;	| xml elements |	changelog		addPundle: (StubPackage named: 'Package');		noteDeletedPundle: (PundleSpec forPackage: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Package';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEmptyLogWhenNoChanges	&lt;test&gt;	| xml |	xml := changelog asXML.	self assert: xml root isEmpty</body><body package="StoreCI-Polling-Tests">generatesEntryForDeletedBundle	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forBundle: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'bundle';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEntryForDeletedPackage	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forPackage: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'package';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Deleted'</body><body package="StoreCI-Polling-Tests">generatesEntryForSingleBundle	&lt;test&gt;	| xml elements |	changelog addPundle: (StubBundle named: 'Bundle').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'bundle';		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'Bundle'</body><body package="StoreCI-Polling-Tests">generatesEntryForSinglePackage	&lt;test&gt;	| xml elements |	changelog addPundle: (StubPackage named: 'Package').	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 1;		assert: elements first expandedName = 'package';		assert: (elements first valueOfAttribute: 'name' ifAbsent: [''])					= 'Package'</body><body package="StoreCI-Polling-Tests">generatesNewestPundlesFirst	&lt;test&gt;	| xml elements older now newer |	now := Timestamp now.	older := StubPackage named: 'Older'.	older timestamp: now - 1 hours.	newer := StubBundle named: 'Newer'.	newer timestamp: now.	changelog		addPundle: older;		addPundle: newer.	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'Newer';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Older'</body><body package="StoreCI-Polling-Tests">generatesRootXMLElement	&lt;test&gt;	| xml |	xml := changelog asXML.	self assert: xml root expandedName = 'log'</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionIfAlreadyAdded	&lt;test&gt;	| head |	head := StubPackage named: 'Package'.	changelog addPundle: head.	changelog noteHeadRevision: head.	self assert: changelog size = 1</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionIfNil	&lt;test&gt;	changelog noteHeadRevision: nil.	self assert: changelog isEmpty</body><body package="StoreCI-Polling-Tests">ignoresHeadRevisionOfKnownPundle	&lt;test&gt;	| head |	changelog := Changelog knownPundles: (KnownPundleCache						withAll: (Array with: (PundleSpec forBundle: 'Bundle'))).	head := StubBundle named: 'Bundle'.	changelog noteHeadRevision: head.	self assert: changelog isEmpty</body><body package="StoreCI-Polling-Tests">marksDeletedPundlesAsDeleted	&lt;test&gt;	| xml elements |	changelog noteDeletedPundle: (PundleSpec forBundle: 'Deleted').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'deleted'</body><body package="StoreCI-Polling-Tests">marksKnownPundlesAsModified	&lt;test&gt;	| xml elements |	changelog := Changelog knownPundles: (KnownPundleCache						withAll: (Array with: (PundleSpec forPackage: 'Package'))).	changelog addPundle: (StubPackage named: 'Package').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'modified'</body><body package="StoreCI-Polling-Tests">marksNewPundlesAsAdded	&lt;test&gt;	| xml elements |	changelog addPundle: (StubBundle named: 'Bundle').	xml := changelog asXML.	elements := xml root elements.	self assert: (elements first valueOfAttribute: 'action' ifAbsent: [''])				= 'added'</body><body package="StoreCI-Polling-Tests">preservesOrderOfSimultaneousPundles	&lt;test&gt;	| xml elements first now second |	now := Timestamp now.	first := StubPackage named: 'First'.	first timestamp: now.	second := StubBundle named: 'Second'.	second timestamp: now.	changelog		addPundle: first;		addPundle: second.	xml := changelog asXML.	elements := xml root elements.	self		assert: elements size = 2;		assert: (elements first valueOfAttribute: 'name' ifAbsent: ['']) = 'First';		assert: (elements last valueOfAttribute: 'name' ifAbsent: ['']) = 'Second'</body><body package="StoreCI-Polling-Tests">remembersHeadRevision	&lt;test&gt;	| head |	head := StubPackage named: 'Package'.	changelog noteHeadRevision: head.	self assert: (changelog includes: head)</body><body package="StoreCI-Polling-Tests">writesXMLHeader	&lt;test&gt;	| expected ws |	expected := '&lt;?xml version="1.0"?&gt;'.	ws := String new writeStream.	changelog writeToStream: ws.	self assert: (ws contents first: expected size) = expected</body></methods><methods><class-id>StoreCI.Polling.BlessingNotFoundTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">hasCorrectErrorMessage	&lt;test&gt;	| expected |	expected := 'Could not find a blessing level named "NoSuchBlessing"'.	[BlessingNotFound raiseWith: 'NoSuchBlessing'] on: BlessingNotFound		do: [:ex | self assert: ex errorString = expected]</body></methods><methods><class-id>StoreCI.Polling.RevisionStateTest</class-id> <category>tests</category><body package="StoreCI-Polling-Tests">findsBundleAndComponentWithPrerequisites	&lt;test&gt;	| state packageDependency bundleDependency shared package bundle expected |	packageDependency := PundleSpec forPackage: 'PackageDependency'.	bundleDependency := PundleSpec forPackage: 'BundleDependency'.	shared := PundleSpec forPackage: 'SharedDependeny'.	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: packageDependency;		setUpPundle: bundleDependency;		setUpPundle: shared;		setUpPundle: package			withPrerequisites: (Array with: packageDependency with: shared);		setUpPundle: bundle			withPrerequisites: (Array with: shared with: bundleDependency);		addChild: package toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	expected := (OrderedCollection new)				add: shared;				add: bundleDependency;				add: packageDependency;				add: package;				add: bundle;				yourself.	self assert: state specs asArray = expected asArray</body><body package="StoreCI-Polling-Tests">findsEmptyBundleWithNoPrerequisites	&lt;test&gt;	| state pundle |	pundle := PundleSpec forBundle: 'EmptyBundle'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle).	self assert: state specs asArray = (Array with: pundle)</body><body package="StoreCI-Polling-Tests">findsMultiplePackagesWithNoPrerequisites	&lt;test&gt;	| state roots |	roots := #('LonelyPackageA' 'LonelyPackageB')				collect: [:each | PundleSpec forPackage: each].	roots do: [:each1 | self setUpPundle: each1].	state := self revisionStateFrom: roots.	self assert: state specs asArray = roots</body><body package="StoreCI-Polling-Tests">findsNestedBundleWithNoPrerequisites	&lt;test&gt;	| state outer package inner |	package := PundleSpec forPackage: 'Package'.	inner := PundleSpec forBundle: 'Inner'.	outer := PundleSpec forBundle: 'Outer'.	self		setUpPundle: package;		setUpPundle: inner;		setUpPundle: outer.	self addChild: package toBundle: inner.	self addChild: inner toBundle: outer.	state := self revisionStateFrom: (Array with: outer).	self		assert: state specs asArray = (Array with: package with: inner with: outer)</body><body package="StoreCI-Polling-Tests">findsPackageThatDependsOnABundle	&lt;test&gt;	| state package bundle |	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: bundle;		setUpPundle: package withPrerequisite: bundle.	state := self revisionStateFrom: (Array with: package).	self assert: state specs asArray = (Array with: bundle with: package)</body><body package="StoreCI-Polling-Tests">findsPackageThatDependsOnBundleComponent	&lt;test&gt;	| state package bundle component |	package := PundleSpec forPackage: 'Package'.	component := PundleSpec forPackage: 'Component'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: component;		setUpPundle: package withPrerequisite: component;		setUpPundle: bundle;		addChild: component toBundle: bundle.	state := self revisionStateFrom: (Array with: package with: bundle).	self assert: state specs asArray				= (Array with: component with: package with: bundle)</body><body package="StoreCI-Polling-Tests">findsPackageWithOnePrerequisite	&lt;test&gt;	| state dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: dependency with: root)</body><body package="StoreCI-Polling-Tests">findsPackageWithSeveralPrerequisites	&lt;test&gt;	| state child1 child2 root |	child1 := PundleSpec forPackage: 'Child1'.	child2 := PundleSpec forPackage: 'Child2'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: child1;		setUpPundle: child2;		setUpPundle: root withPrerequisites: (Array with: child1 with: child2).	state := self revisionStateFrom: (Array with: root).	self		assert: state specs asArray = (Array with: child1 with: child2 with: root)</body><body package="StoreCI-Polling-Tests">findsPrerequisiteChain	&lt;test&gt;	| state child parent grandparent |	child := PundleSpec forPackage: 'Child'.	parent := PundleSpec forPackage: 'Parent'.	grandparent := PundleSpec forPackage: 'Grandparent'.	self		setUpPundle: child;		setUpPundle: parent withPrerequisite: child;		setUpPundle: grandparent withPrerequisite: parent.	state := self revisionStateFrom: (Array with: grandparent).	self assert: state specs asArray				= (Array with: child with: parent with: grandparent)</body><body package="StoreCI-Polling-Tests">findsSimpleBundleWithNoPrerequisites	&lt;test&gt;	| state bundle package |	package := PundleSpec forPackage: 'Package'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: package;		setUpPundle: bundle.	self addChild: package toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	self assert: state specs asArray = (Array with: package with: bundle)</body><body package="StoreCI-Polling-Tests">findsSimpleBundleWithOnePrerequisite	&lt;test&gt;	| state dependency component bundle |	dependency := PundleSpec forPackage: 'Dependency'.	component := PundleSpec forPackage: 'Component'.	bundle := PundleSpec forBundle: 'Bundle'.	self		setUpPundle: dependency;		setUpPundle: component;		setUpPundle: bundle withPrerequisite: dependency;		addChild: component toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	self assert: state specs asArray				= (Array with: dependency with: component with: bundle)</body><body package="StoreCI-Polling-Tests">findsSinglePackageWithNoPrerequisites	&lt;test&gt;	| state pundle |	pundle := PundleSpec forPackage: 'LonelyPackage'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle).	self assert: state specs asArray = (Array with: pundle)</body><body package="StoreCI-Polling-Tests">handlesCycles	&lt;test&gt;	| state root child |	root := PundleSpec forPackage: 'Root'.	child := PundleSpec forPackage: 'Child'.	self		setUpPundle: root withPrerequisite: child;		setUpPundle: child withPrerequisite: root.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: child with: root)</body><body package="StoreCI-Polling-Tests">hasNoSpecsUntilComputed	&lt;test&gt;	| state |	state := RevisionState				roots: (Array with: (PundleSpec forPackage: 'Root')).	self assert: state specs isEmpty</body><body package="StoreCI-Polling-Tests">ignoresDuplicates	&lt;test&gt;	| state pundle |	pundle := PundleSpec forPackage: 'LonelyPackage'.	self setUpPundle: pundle.	state := self revisionStateFrom: (Array with: pundle with: pundle copy).	self assert: state specs size = 1</body><body package="StoreCI-Polling-Tests">ignoresMissingPundles	&lt;test&gt;	| state |	state := self				revisionStateFrom: (Array with: (PundleSpec forPackage: 'NoSuchPundle')).	self assert: state specs isEmpty</body><body package="StoreCI-Polling-Tests">includesSharedPrerequisiteOnlyOnce	&lt;test&gt;	| state shared root1 root2 |	shared := PundleSpec forPackage: 'Shared'.	root1 := PundleSpec forPackage: 'Root1'.	root2 := PundleSpec forPackage: 'Root2'.	self		setUpPundle: shared;		setUpPundle: root1 withPrerequisite: shared;		setUpPundle: root2 withPrerequisite: shared.	state := self revisionStateFrom: (Array with: root1 with: root2).	self		assert: state specs asArray = (Array with: shared with: root1 with: root2)</body><body package="StoreCI-Polling-Tests">remembersBundlePrerequisites	&lt;test&gt;	| bundle nestedBundle child1 child2 package1 package2 state bundleRevisions |	bundle := PundleSpec forBundle: 'Bundle'.	nestedBundle := PundleSpec forBundle: 'NestedBundle'.	child1 := PundleSpec forPackage: 'Child1'.	child2 := PundleSpec forPackage: 'Child2'.	package1 := PundleSpec forPackage: 'Package1'.	package2 := PundleSpec forPackage: 'Package2'.	self		setUpPundle: child1;		setUpPundle: child2;		setUpPundle: package1;		setUpPundle: package2;		setUpPundle: nestedBundle withPrerequisite: package2;		setUpPundle: bundle withPrerequisite: package1;		addChild: child2 toBundle: nestedBundle;		addChild: child1 toBundle: bundle;		addChild: nestedBundle toBundle: bundle.	state := self revisionStateFrom: (Array with: bundle).	bundleRevisions := state bundleRevisions.	self assert: bundleRevisions size = 2.	self		assertBundleRevisionsFor: nestedBundle			in: bundleRevisions			match: #('Package2' 'Child2' 'NestedBundle');		assertBundleRevisionsFor: bundle			in: bundleRevisions			match: #('Package1' 'Child1' 'Package2' 'Child2' 'NestedBundle' 'Bundle')</body><body package="StoreCI-Polling-Tests">skipsParcelOnlyPrerequisites	&lt;test&gt;	| state dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	(registry at: root) prerequisiteDescriptions first loadResolution: #parcel.	state := self revisionStateFrom: (Array with: root).	self assert: state specs asArray = (Array with: root)</body><body package="StoreCI-Polling-Tests">writesToStream	&lt;test&gt;	| state ws expectedContents dependency root |	dependency := PundleSpec forPackage: 'Dependency'.	root := PundleSpec forPackage: 'Root'.	self		setUpPundle: dependency;		setUpPundle: root withPrerequisite: dependency.	state := self revisionStateFrom: (Array with: root).	ws := String new writeStream.	state writeOn: ws.	expectedContents := 'StorePackage&lt;t&gt;"Dependency"&lt;t&gt;42StorePackage&lt;t&gt;"Root"&lt;t&gt;42'				expandMacros.	self assert: ws contents = expectedContents</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootPundles versionMatcher minimumBlessingLevel repository parcelBuilderInputFile outputStream lastBuildTime currentTime changelogFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>StoreCISubsystemTest</name><environment>StoreCI.Support</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorStream system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support-Tests</package></attributes></class></st-source>