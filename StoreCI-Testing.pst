<?xml version="1.0"?><st-source><!-- Name: StoreCI-TestingNotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: # StoreCIIntegrate Cincom Visualworks Smalltalk with a Continuous Integration server.StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.StoreCI's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/StoreCI).StoreCI was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  It uses the newer Glorp-based Store implementation, so will not work in 7.6 or earlier.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# StoreCI-TestingStoreCI-Testing runs a set of SUnitToo test cases and outputs the results in a JUnit-compatible XML format.  It is intended to be used as part of an automated build, perhaps driven from a Continuous Integration system such as Jenkins or CruiseControl.## UsageStoreCI-Testing is intended to be run from a command-line or automated build script.  It requires an image that has the tests to be run and StoreCI-Testing already loaded, or with a base image and command-line options to load all of the code from parcels.  A common way to generate the parcels is by using StoreCI-Building to deploy them in an earlier part of the build process.Run the image as follows:	/path/to/VM /path/to/image <command-line options>or:	/path/to/VM /path/to/image -pcl <Top-level parcel> -pcl StoreCI-Testing <command-line options>The allowable command line options are:* (Required) `-testResultsFile <Filename>`: The name of the file to which the JUnit-format XML results will be written.* (Optional) `-traceFile <Filename>`: The name of a file to which trace information will be written while tests are running.  This is useful for debugging purposes if tests start hanging in the automated build, or if they randomly fail due to test ordering issues.  A line is added to this file when a test is started, and another line is added when it completes.* (Optional) `-testPackages <list of Package names>` / `-testBundles <list of Bundle names>` / `-testClasses <list of Class names>`: By default, StoreCI-Testing runs all of the tests in the image.  These options cause StoreCI-Testing to restrict itself to only those tests in the specified packages or bundles, or only the test classes explicitly listed.* (Optional) `-debug`: When specified, exceptions will not be trapped and the image will not exit upon completion.## Understanding the Code`TestingSubsystem` is the main entry point for the command-line application.  It processes command-line arguments, asks `SuiteBuilder` to build a test suite to be run by `SuiteRunner`.  Results are captured into `SuiteResults` and are wriitten to the output file by `XMLResultWriter`.  See the class and method comments for more information.# ContributingI'm happy to receive bug fixes and improvements to this package.  If you'd like to contribute, please publish your changes as a "branch" (non-integer) version in the Public Store Repository and contact me as outlined below to let me know.  I will merge your changes back into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about this package and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1451DbUsername: randyDbVersion: 79DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'StoreCI-Support' '') #(#any 'SUnitToo' ''))IgnoredPrerequisites: #()Namespace: StoreCI.TestingPackageName: StoreCI-TestingParcel: #('StoreCI-Testing')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'StoreCI-Support' #componentType #package) #(#name 'SUnitToo'))PrerequisiteParcels: #(#('Base VisualWorks' '') #('StoreCI-Support' '') #('SUnitToo' ''))PrintStringCache: (79,randy)Version: 79Date: 10:20:13 PM March 31, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on March 31, 2013 at 10:20:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Testing</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private SUnit.*			private XML.*			</imports><category></category><attributes><package>StoreCI-Testing</package></attributes></name-space><class><name>SuiteBuilder</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>includedClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteBuilder</class-id><body>SuiteBuilder creates a TestSuite containing a possibly filtered list all of the SUnitToo tests in the image.Instance Variables	includedClasses	&lt;Set&gt;	The TestCase classes to include, or nil if no filtering should be done.</body></comment><class><name>TestingSubsystem</name><environment>StoreCI.Testing</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputFile suiteBuilder suiteRunner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TestLogger</category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.TestingSubsystem</class-id><body>TestingSubsystem is the main command-line entry point for StoreCI-Testing.  See the package comment for details on usage and command-line options.TestingSubsystem is designed to be inert unless it is given an output file.  If that is provided, it uses SuiteBuilder to build a test suite containing an optionally filtered list of all of the tests in the image.  It then uses SuiteRunner to run the tests, and XMLResultWriter to write out the SuiteResults in JUnit XML format.[This answer on StackOverflow](http://stackoverflow.com/a/9691131/667070) provides the best reference I've found for this format.Instance Variables	outputFile	&lt;Filename&gt;	The file to which XML results will be written.	suiteBuilder	&lt;SuiteBuilder&gt;	Used to build a suite containing a possibly filtered list of all of the tests in the curent Image.	suiteRunner	&lt;SuiteRunner&gt;	Runs the test suite, collecting the results.</body></comment><class><name>SuiteRunner</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results observers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteRunner</class-id><body>SuiteRunner runs a test suite, informing its observers (including a SuiteResults) of progress and results.Instance Variables	observers	&lt;(Collection of: ResultObserver)&gt;	Observers that are interested in test progress and results.	results	&lt;SuiteResults&gt;	The overall results of running the suite.</body></comment><class><name>ResultObserver</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.ResultObserver</class-id><body>ResultObserver is the base class of all classes that are interested in test and test suite results.It observes TestCase and sends itself #testStarted: and #testFinished: in response to the announcements it receives.  It also expects its owner to call #setUp/#tearDown and #suiteStarted/#suiteFinished: appropriately.</body></comment><class><name>SuiteResults</name><environment>StoreCI.Testing</environment><super>StoreCI.Testing.ResultObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results suiteTimer testTimer testElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.SuiteResults</class-id><body>SuiteResults contains the full set of results of running a test suite.  In addition to the basic SUnit.Results, it keeps track of test and suite runtimes.  It also builds up the XML Elements representing each test case as it goes so that it can capture exception descriptions and stack traces.  Otherwise, that information is lost before the end of the test run.Instance Variables	results	&lt;ResultsWithSkips&gt;	The basic SUnitToo results of the test run.	suiteTimer	&lt;TestTimer&gt;	A timer for tracking overall suite runtime.	testElements	&lt;Dictionary&gt;	XML Elements representing the results of each test case.	testTimer	&lt;TestTimer&gt;	A timer for tracking individual test runtimes.</body></comment><class><name>XMLResultWriter</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.XMLResultWriter</class-id><body>XMLResultWriter writes the suite results to a file in JUnit XML format.Instance Variables	filename	&lt;Filename&gt;	The name of the file to write to.</body></comment><class><name>Trace</name><environment>StoreCI.Testing</environment><super>StoreCI.Testing.ResultObserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.Trace</class-id><body>Trace writes test start and finish events to an output stream.  This is useful for debugging hanging tests or random test failures caused by test ordering issues.Instance Variables	filename	&lt;Filename&gt;	The name of the file to write the trace information to.	stream	&lt;Stream&gt;	A writeStream on the file; kept open while the tests are running.</body></comment><class><name>ResultsWithSkips</name><environment>StoreCI.Testing</environment><super>SUnit.Results</super><private>false</private><indexed-type>none</indexed-type><inst-vars>skipped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.ResultsWithSkips</class-id><body>ResultsWithSkips is a SUnit.Results subclass that keeps track of any tests that were skipped.Instance Variables	skipped	&lt;Collection&gt;	The set of skipped test cases.</body></comment><class><name>TestTimer</name><environment>StoreCI.Testing</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startTime elapsed clock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.TestTimer</class-id><body>A simple Timer used to keep track of test and suite runtimes.Instance Variables	clock	&lt;StubClock | Time&gt;	The clock to use when keeping track of time.	elapsed	&lt;Duration&gt;	The amount of time the timer was running.	startTime	&lt;LargeInteger&gt;	The microsecond clock value when the timer was started.</body></comment><class><name>Skip</name><environment>StoreCI.Testing</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Testing</package></attributes></class><comment><class-id>StoreCI.Testing.Skip</class-id><body>An SUnit.Result representing a test case that was skipped.</body></comment><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>filtering</category><body package="StoreCI-Testing">includeClasses: aCollection	"Include all of the test classes in aCollection in the list of tests to run."	self includedClasses addAll: aCollection</body><body package="StoreCI-Testing">includePundles: aCollection	"Include any TestCase classes defined in the pundles in aCollection in the list of tests to run."	aCollection do: 			[:each |			self includedClasses addAll: (each definedClasses						select: [:eachClass | eachClass isTestCase and: [eachClass isAbstract not]])]</body></methods><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>private</category><body package="StoreCI-Testing">includedClasses	"Lazy initialize only when needed.  If nil, we don't want to filter the list of tests."	^includedClasses ifNil: [includedClasses := Set new]</body></methods><methods><class-id>StoreCI.Testing.SuiteBuilder</class-id> <category>accessing</category><body package="StoreCI-Testing">suite	| suite classes |	classes := includedClasses ifNil: [TestCase withAllSubclasses].	suite := TestSuite new.	(classes reject: #isAbstract) do: 			[:eachClass |			eachClass				testSelectorsDo: [:eachSelector | suite addTest: (eachClass selector: eachSelector)]].	^suite</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>private</category><body package="StoreCI-Testing">basicRun	suiteRunner runSuite: suiteBuilder suite.	self writeResults: suiteRunner results.	^suiteRunner hasPassed</body><body package="StoreCI-Testing">run	self basicRun ifFalse: [^self error: 'Tests failed']</body><body package="StoreCI-Testing">writeResults: aSuiteResults	| writer |	writer := XMLResultWriter onFile: outputFile.	writer write: aSuiteResults</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Testing">clearCachedState	super clearCachedState.	outputFile := nil.	suiteBuilder := self makeSuiteBuilder.	suiteRunner := SuiteRunner new</body><body package="StoreCI-Testing">makeSuiteBuilder	^SuiteBuilder new</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>private-testing</category><body package="StoreCI-Testing">isReadyToRun	^outputFile notNil</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	observers := OrderedCollection new.	results := SuiteResults new.	self addObserver: results</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>accessing</category><body package="StoreCI-Testing">addObserver: aResultObserver	observers add: aResultObserver</body><body package="StoreCI-Testing">results	^results</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>testing</category><body package="StoreCI-Testing">hasPassed	^results hasPassed</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>running</category><body package="StoreCI-Testing">runSuite: aTestSuite	"Run aTestSuite, informing my observers of progress and results."	observers do: #setUp.		[| sunitResults |	observers do: #suiteStarted.	sunitResults := self basicRunSuite: aTestSuite.	observers do: [:each | each suiteFinished: sunitResults]]			ensure: [observers do: #tearDown]</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner</class-id> <category>private</category><body package="StoreCI-Testing">basicRunSuite: aTestSuite	"TestSuite doesn't allow injection of a results class, so we wrap our suite run in an outer #collectWhile:.	This is redundant, but allows us to collect tests that are skipped due to resource unavailability."	^ResultsWithSkips collectWhile: 			[[aTestSuite run] on: TestResourceUnavailable				do: 					[:ex |					(aTestSuite definitionsForResources: ex parameter)						do: [:each | TestCase announce: (Skip definition: each)].					ex resume]]</body></methods><methods><class-id>StoreCI.Testing.SuiteRunner class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>life cycle</category><body package="StoreCI-Testing">setUp	TestCase when: Started send: #testStarted: to: self.	TestCase when: Result send: #testFinished: to: self</body><body package="StoreCI-Testing">tearDown	TestCase unsubscribe: self</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>test events</category><body package="StoreCI-Testing">suiteFinished: aResults	"Do nothing by default"	</body><body package="StoreCI-Testing">suiteStarted	"Do nothing by default"	</body></methods><methods><class-id>StoreCI.Testing.ResultObserver</class-id> <category>private - test events</category><body package="StoreCI-Testing">testFinished: aTestResult	"Do nothing by default"	</body><body package="StoreCI-Testing">testStarted: aTestStarted	"Do nothing by default"	</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	suiteTimer := TestTimer new.	testTimer := TestTimer new.	testElements := Dictionary new.	results := ResultsWithSkips new</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - test support</category><body package="StoreCI-Testing">injectClock: aClock	suiteTimer injectClock: aClock.	testTimer injectClock: aClock</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>accessing</category><body package="StoreCI-Testing">asXML	"Answer an XML Document representing the test results in JUnit format."	| root |	root := self suiteElement.	self addTestCaseElementsTo: root.	^XML.Document new addNode: root</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>test events</category><body package="StoreCI-Testing">suiteFinished: aResults	suiteTimer stop.	results := aResults</body><body package="StoreCI-Testing">suiteStarted	suiteTimer start</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - xml</category><body package="StoreCI-Testing">addTestCaseElementsTo: anElement	self sortedResults do: [:each | anElement addNode: each]</body><body package="StoreCI-Testing">addTime: aDuration toElement: anElement	| formattedTime |	formattedTime := aDuration asSeconds printFormat: '0.000'.	anElement addAttribute: (Attribute name: 'time' value: formattedTime)</body><body package="StoreCI-Testing">sortedResults	| sortedKeys |	sortedKeys := testElements keys				asSortedCollection: [:a :b | a definition &lt; b definition].	^sortedKeys collect: [:each | testElements at: each]</body><body package="StoreCI-Testing">suiteElement	| root |	root := Element tag: 'testsuite'.	root addAttribute: (Attribute name: 'name' value: 'allTests').	results addSummaryAttributesTo: root.	self addTime: suiteTimer elapsed toElement: root.	^root</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>testing</category><body package="StoreCI-Testing">hasPassed	^results allPassed</body></methods><methods><class-id>StoreCI.Testing.SuiteResults</class-id> <category>private - test events</category><body package="StoreCI-Testing">testFinished: aResult	| element |	testTimer stop.	element := aResult asTestLoggerXML.	self addTime: testTimer elapsed toElement: element.	testElements at: aResult put: element</body><body package="StoreCI-Testing">testStarted: aStarted	testTimer start</body></methods><methods><class-id>StoreCI.Testing.SuiteResults class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initializeFilename: aFilename	filename := aFilename</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>writing</category><body package="StoreCI-Testing">write: aResults	| ws |	ws := filename writeStream.	[self writeResults: aResults to: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter</class-id> <category>private</category><body package="StoreCI-Testing">writeResults: aSuiteResults to: aStream	| xml |	aStream		nextPutAll: '&lt;?xml version="1.0"?&gt;';		cr.	xml := aSuiteResults asXML.	xml saxDo: (SAXWriter new output: aStream).	aStream flush</body></methods><methods><class-id>StoreCI.Testing.XMLResultWriter class</class-id> <category>instance creation</category><body package="StoreCI-Testing">onFile: aFilename	^self new initializeFilename: aFilename</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initializeFilename: aFilename	filename := aFilename</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>life cycle</category><body package="StoreCI-Testing">setUp	super setUp.	stream := filename writeStream</body><body package="StoreCI-Testing">tearDown	stream close.	super tearDown</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>test events</category><body package="StoreCI-Testing">testFinished: aResult	self log: aResult</body><body package="StoreCI-Testing">testStarted: aStarted	self log: aStarted</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>private - test support</category><body package="StoreCI-Testing">injectStream: aStream	stream := aStream</body></methods><methods><class-id>StoreCI.Testing.Trace</class-id> <category>private</category><body package="StoreCI-Testing">log: aTestCaseAnnouncement	stream		nextPutAll: aTestCaseAnnouncement definition printString;		space;		nextPutAll: aTestCaseAnnouncement class name;		cr;		flush</body></methods><methods><class-id>StoreCI.Testing.Trace class</class-id> <category>instance creation</category><body package="StoreCI-Testing">onFile: aFilename	^self new initializeFilename: aFilename</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>accessing</category><body package="StoreCI-Testing">addSkip: aSkip	skipped add: aSkip</body><body package="StoreCI-Testing">addSummaryAttributesTo: anElement	anElement		addAttribute: (Attribute name: 'tests' value: self runCount printString);		addAttribute: (Attribute name: 'failures'					value: self failureCount printString);		addAttribute: (Attribute name: 'errors' value: self errorCount printString);		addAttribute: (Attribute name: 'skipped'					value: self skippedCount printString)</body><body package="StoreCI-Testing">ranCount	^super ranCount + self skippedCount</body><body package="StoreCI-Testing">skippedCount	^skipped size</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>printing</category><body package="StoreCI-Testing">countSelectors	^super countSelectors copyWith: #skippedCount</body></methods><methods><class-id>StoreCI.Testing.ResultsWithSkips</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	skipped := Set new</body></methods><methods><class-id>StoreCI.Testing.TestTimer</class-id> <category>accessing</category><body package="StoreCI-Testing">elapsed	^elapsed</body><body package="StoreCI-Testing">start	startTime := clock microsecondClock</body><body package="StoreCI-Testing">stop	elapsed := startTime				ifNil: [0 microseconds]				ifNotNil: [(clock microsecondClock - startTime) microseconds]</body></methods><methods><class-id>StoreCI.Testing.TestTimer</class-id> <category>initialize-release</category><body package="StoreCI-Testing">initialize	super initialize.	clock := Time.	elapsed := 0 microseconds</body><body package="StoreCI-Testing">injectClock: aClock	clock := aClock</body></methods><methods><class-id>StoreCI.Testing.TestTimer class</class-id> <category>instance creation</category><body package="StoreCI-Testing">new	^super new initialize</body></methods><methods><class-id>StoreCI.Testing.Skip</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	^(super asTestLoggerXML)		addNode: (Element tag: 'skipped');		yourself</body></methods><methods><class-id>StoreCI.Testing.Skip</class-id> <category>accessing</category><body package="StoreCI-Testing">addTo: aResults	"There may be multiple SUnit.Results instances listening, but only some know about skipped tests."	(aResults respondsTo: #addSkip:) ifFalse: [^self].	aResults addSkip: self</body></methods><methods><class-id>StoreCI.Testing.Skip class</class-id> <category>instance creation</category><body package="StoreCI-Testing">definition: aMethodDefinition	^self new definition: aMethodDefinition</body></methods><methods><class-id>StoreCI.Testing.TestingSubsystem</class-id> <category>command-line</category><body package="StoreCI-Testing">testBundles: aStream	&lt;option: '-testBundles'&gt;	| bundles |	bundles := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | Store.Registry bundleNamed: each].	suiteBuilder includePundles: bundles</body><body package="StoreCI-Testing">testClasses: aStream	&lt;option: '-testClasses'&gt;	| classes |	classes := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | each asQualifiedReference value].	suiteBuilder includeClasses: classes</body><body package="StoreCI-Testing">testPackages: aStream	&lt;option: '-testPackages'&gt;	| packages |	packages := (CommandLineInterest argumentsFrom: aStream)				collect: [:each | Store.Registry packageNamed: each].	suiteBuilder includePundles: packages</body><body package="StoreCI-Testing">testResultsFile: aStream	&lt;option: '-testResultsFile'&gt;	outputFile := aStream next asFilename</body><body package="StoreCI-Testing">traceFile: aStream	&lt;option: '-traceFile'&gt;	suiteRunner addObserver: (Trace onFile: aStream next asFilename)</body></methods><methods><class-id>SUnit.ExceptionalResult</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	| element |	element := Element				tag: self testLoggerXMLTag				attributes: (Array						with: (Attribute name: 'message' value: exception errorString)						with: (Attribute name: 'type' value: exception class name asString))				elements: (Array with: (XML.Text text: self testLoggerXMLDetails)).	^(super asTestLoggerXML)		addNode: element;		yourself</body><body package="StoreCI-Testing">testLoggerXMLDetails	^((String new: 100) writeStream)		nextPutAll: exception description;		cr;		nextPutAll: exception initialContext printStack;		contents</body><body package="StoreCI-Testing">testLoggerXMLTag	^self subclassResponsibility</body></methods><methods><class-id>SUnit.SomeError</class-id> <category>converting</category><body package="StoreCI-Testing">testLoggerXMLTag	^'error'</body></methods><methods><class-id>SUnit.Failure</class-id> <category>converting</category><body package="StoreCI-Testing">testLoggerXMLTag	^'failure'</body></methods><methods><class-id>SUnit.Result</class-id> <category>converting</category><body package="StoreCI-Testing">asTestLoggerXML	^Element		tag: 'testcase'		attributes: (Array				with: (Attribute new name: 'name' value: self definition printString))		elements: nil</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Result</name><environment>SUnit</environment><super>SUnit.TestCaseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>ExceptionalResult</name><environment>SUnit</environment><super>SUnit.Result</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>Results</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors passes failures </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>StoreCISubsystem</name><environment>StoreCI.Support</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debug errorStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support</package></attributes></class><class><name>Failure</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class><class><name>SomeError</name><environment>SUnit</environment><super>SUnit.ExceptionalResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitToo</category><attributes><package>SUnitToo</package></attributes></class></st-source>